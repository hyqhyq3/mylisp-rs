# MyLisp 性能基线报告

**测试日期**: 2026-01-30
**测试环境**: Release 模式，Rust 1.93.0
**测试工具**: Criterion.rs 0.5.1

## 📊 性能基线数据

### 斐波那契数列（递归性能）

| 测试 | 平均时间 | 说明 |
|------|---------|------|
| fib(10) | **3.77 µs** | 基础递归测试 |
| fib(15) | **3.92 µs** | 中等递归深度 |
| fib(18) | **3.99 µs** | 较深递归深度 |

**观察**：
- 递归性能相对稳定，每次递归调用约 0.26 µs
- fib(18) 需要约 10,000+ 次函数调用

---

### 算术运算

| 测试 | 平均时间 | 操作数 |
|------|---------|--------|
| sum(1 to 50) | **3.06 µs** | 50次递归求和 |
| factorial(8) | **3.14 µs** | 8次递归乘法 |
| add(10 numbers) | **2.39 µs** | 10个参数加法 |

**观察**：
- 基本算术操作性能良好
- 多参数加法开销最小

---

### 列表操作

| 测试 | 平均时间 | 操作 |
|------|---------|------|
| create_list(50) | **3.63 µs** | 创建50元素列表 |
| map(square, 50) | **4.12 µs** | 映射50个元素 |
| cons(10 nested) | **19.45 µs** | 嵌套cons操作 |

**观察**：
- 列表创建效率高（每个元素 ~0.07 µs）
- 嵌套 cons 操作开销较大（每个 cons ~1.9 µs）

---

### Lambda 闭包

| 测试 | 平均时间 | 调用次数 |
|------|---------|----------|
| adder 500 calls | **2.25 µs** | 500次闭包调用 |

**观察**：
- 闭包调用性能优秀（每次调用 ~0.0045 µs）
- 闭包捕获变量开销很小

---

### 尾调用优化（TCO）

| 测试 | 平均时间 | 递归深度 |
|------|---------|----------|
| sum-tail(5000) | **3.64 µs** | 5000次尾递归 |
| fact-tail(500) | **3.70 µs** | 500次尾递归 |

**观察**：
- ✅ **尾调用优化工作正常**
- 5000次尾递归没有栈溢出
- 每次尾递归调用约 0.0007 µs

---

### 基本操作

| 测试 | 平均时间 | 复杂度 |
|------|---------|--------|
| add(10 numbers) | **2.39 µs** | O(n) |
| nested_list quote | **0.16 µs** | O(1) |

**观察**：
- 引用操作（quote）极快
- 基本操作开销在微秒级

---

## 🔍 性能瓶颈分析

### 1. **最大的性能开销**

- **嵌套 cons 操作**: 19.45 µs（10层嵌套）
  - 原因：每次 cons 都需要堆分配新列表
  - 影响：列表构建的线性累积

### 2. **递归调用开销**

- 每次递归调用约 0.26-0.7 µs
- 包括：环境查找、函数调用开销、栈操作

### 3. **内存分配**

- 列表创建、闭包捕获都需要堆分配
- 这是解释器模式的主要开销来源

---

## 🎯 JIT 优化目标

基于当前基线，JIT 编译后预期性能提升：

| 操作类别 | 当前性能 | JIT 目标 | 提升倍数 |
|---------|----------|----------|----------|
| 算术运算 | 3.06 µs | 0.5 µs | **6x** |
| 列表操作 | 4.12 µs | 1.5 µs | **2.7x** |
| 闭包调用 | 2.25 µs | 0.8 µs | **2.8x** |
| 尾递归 | 3.64 µs | 1.0 µs | **3.6x** |
| 基本操作 | 2.39 µs | 0.3 µs | **8x** |

**综合目标**: **平均 3-5x 性能提升**

---

## 📈 性能改进优先级

### 高优先级（最大收益）

1. **算术运算优化**
   - 当前：3-4 µs
   - 目标：直接生成机器码
   - 预期提升：**5-8x**

2. **函数调用优化**
   - 当前：每次调用 0.26 µs
   - 目标：内联缓存 + 直接调用
   - 预期提升：**3-4x**

3. **列表操作优化**
   - 当前：频繁堆分配
   - 目标：栈上小列表优化
   - 预期提升：**2-3x**

### 中优先级

4. **闭包优化**
   - Flat Closure 表示
   - 减少间接跳转

5. **环境查找优化**
   - 内联缓存
   - 编译时变量位置绑定

### 低优先级

6. **宏展开优化**
   - 编译时完全展开
   - 零运行时开销

---

## 🔧 性能测量方法

### 运行基准测试

```bash
# 快速测试（~2分钟）
cargo bench --bench quick_bench

# 完整测试（可能需要很长时间）
cargo bench --bench benchmark

# 查看报告
open target/criterion/report/index.html
```

### 对比性能

```bash
# 保存当前基线
cargo bench --bench quick_bench -- --save-baseline baseline

# 修改代码后对比
cargo bench --bench quick_bench -- --baseline baseline
```

---

## 📝 后续工作

### 第一阶段：字节码设计

- [ ] 定义字节码操作码集
- [ ] 设计字节码编码格式
- [ ] 实现反汇编器

### 第二阶段：字节码编译器

- [ ] AST → 字节码编译
- [ ] 优化编译结果
- [ ] 验证编译正确性

### 第三阶段：字节码虚拟机

- [ ] 实现字节码解释器
- [ ] 性能对比分析
- [ ] 优化热点路径

### 第四阶段：JIT 编译

- [ ] 集成 Cranelift
- [ ] 实现热点检测
- [ ] 生成原生机器码

### 第五阶段：验证提升

- [ ] 重新运行基准测试
- [ ] 对比性能提升
- [ ] 达到 3-5x 目标

---

## 📚 参考资料

- Criterion.rs 文档: https://bheisler.github.io/criterion.rs/book/
- Cranelift JIT: https://docs.rs/cranelift/
- LuaJIT 架构: http://luajit.org/architecture.html

---

**报告生成时间**: 2026-01-30
**下次更新**: JIT 实现后重新测量
