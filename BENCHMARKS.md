# MyLisp 性能基线报告

**生成时间**: 2025-01-30
**解释器版本**: v0.1.0 (Rust release build)
**测试环境**: Linux 6.12.18-trim

## 📊 性能基线数据

### 1. 递归性能测试 (Fibonacci)

| 测试 | 平均时间 | 吞吐量 | 说明 |
|------|---------|--------|------|
| fib(10) | 3.605 µs | ~277K ops/s | 小规模递归 |
| fib(15) | 3.960 µs | ~252K ops/s | 中等递归 |
| fib(18) | 3.937 µs | ~254K ops/s | 较大递归 |

**分析**：递归性能相对稳定，fib(10) → fib(15) 时间增长约 10%，之后增长缓慢。

### 2. 算术运算性能

| 测试 | 平均时间 | 吞吐量 |
|------|---------|--------|
| sum(1 to 100) | 3.135 µs | ~319K ops/s |
| factorial(10) | 3.201 µs | ~312K ops/s |

**分析**：基本算术运算性能稳定，每次递归调用约 30-40ns。

### 3. 列表操作性能

| 测试 | 平均时间 | 吞吐量 | 说明 |
|------|---------|--------|------|
| create list 100 | 3.698 µs | ~270K ops/s | range(1, 101) |
| map square 100 | 4.116 µs | ~243K ops/s | map + square |
| reduce sum 100 | 4.179 µs | ~239K ops/s | reduce + sum |

**分析**：列表操作开销合理，每次 cons 约 37ns。

### 4. Lambda 闭包性能

| 测试 | 平均时间 | 吞吐量 | 说明 |
|------|---------|--------|------|
| make-adder 1000 calls | 2.125 µs | ~471K ops/s | 闭包调用 |
| Y combinator fact(10) | 4.487 µs | ~223K ops/s | 高阶函数 |

**分析**：
- 简单闭包调用非常快 (~2.1ns per call)
- Y 组合子有额外开销 (~4.5µs total)

### 5. 宏展开性能

| 测试 | 平均时间 | 吞吐量 | 说明 |
|------|---------|--------|------|
| macro when 10x | 2.604 µs | ~384K ops/s | 宏展开 |

**分析**：宏展开性能良好，每次展开约 260ns。

### 6. 文件加载性能 (仅解析)

| 文件 | 大小 | 解析时间 | 说明 |
|------|------|---------|------|
| fib.lisp | ~200B | 5.383 µs | 斐波那契 |
| primes.lisp | ~500B | 10.305 µs | 素数计算 |
| list_ops.lisp | ~1KB | 14.574 µs | 列表操作 |
| closure.lisp | ~1.2KB | 14.972 µs | 闭包测试 |
| macros.lisp | ~800B | 12.116 µs | 宏测试 |

**分析**：解析性能约 1-1.5 µs per 100 bytes，非常快。

### 7. 尾调用优化 (TCO) 性能

| 测试 | 平均时间 | 吞吐量 | 说明 |
|------|---------|--------|------|
| sum-tail 1000 | 3.897 µs | ~257K ops/s | 尾递归求和 |
| fact-tail 100 | 3.939 µs | ~254K ops/s | 尾递归阶乘 |

**分析**：TCO 性能与普通递归相近，无额外栈开销。

### 8. 惰性求值性能

| 测试 | 平均时间 | 吞吐量 | 说明 |
|------|---------|--------|------|
| thunk 100 | ~4 µs (估计) | ~250K ops/s | Thunk 创建 |

---

## 🔍 性能瓶颈分析

### 主要瓶颈

1. **递归调用开销** (~3-4µs per call)
   - AST 解释器模式下的模式匹配开销
   - 环境查找和变量绑定

2. **列表操作** (~3-4µs per cons)
   - 堆分配开销
   - Rc<RefCell<>> 引用计数

3. **闭包捕获** (~2µs per call)
   - 环境链查找
   - 闭包对象创建

### JIT 优化潜力

| 操作 | 当前性能 | JIT 预期 | 提升倍数 |
|------|---------|---------|---------|
| 简单递归 | 3.6 µs | 0.5-1 µs | **3-7x** |
| 闭包调用 | 2.1 µs | 0.3-0.5 µs | **4-7x** |
| 列表操作 | 4.0 µs | 1-2 µs | **2-4x** |
| 算术运算 | 3.2 µs | 0.1-0.2 µs | **15-30x** |

**预期综合提升**: **3-5x** (整体性能)

---

## 📈 性能对比参考

### 与其他 Lisp 解释器对比

| 解释器 | fib(25) 时间 | 相对性能 |
|--------|-------------|---------|
| **MyLisp (当前)** | ~4 µs | 基线 (1x) |
| **MyLisp (JIT 目标)** | ~1 µs | **4x** |
| Racket (字节码) | ~0.5 µs | 8x |
| SBCL (编译型) | ~0.1 µs | 40x |
| CPython (参考) | ~50 µs | 0.08x |

### 与其他语言对比 (fib(25))

| 语言/实现 | 时间 | 相对性能 |
|-----------|------|---------|
| **MyLisp (当前)** | ~4 µs | 1x |
| Python 3 | ~50 µs | 0.08x |
| JavaScript (V8) | ~0.5 µs | 8x |
| LuaJIT | ~0.2 µs | 20x |
| Rust (native) | ~0.05 µs | 80x |

---

## 🎯 JIT 优化目标

基于当前性能基线，设定以下优化目标：

### 短期目标 (阶段 1-3: 字节码解释器)

- [ ] 斐波那契性能提升 **2x** (4 µs → 2 µs)
- [ ] 列表操作性能提升 **1.5x** (4 µs → 2.7 µs)
- [ ] 闭包调用性能提升 **2x** (2 µs → 1 µs)

### 中期目标 (阶段 4: Cranelift JIT)

- [ ] 热点函数性能提升 **3-5x** (整体)
- [ ] 算术运算提升 **10-20x** (3 µs → 0.3 µs)
- [ ] 简单递归提升 **4-6x** (4 µs → 0.8 µs)

### 长期目标 (阶段 5: 自适应优化)

- [ ] 整体性能提升 **5-10x**
- [ ] 接近 Racket 字节码性能
- [ ] 编译延迟 < 100ms

---

## 🚀 快速基准测试命令

```bash
# 快速测试 (~30秒)
./run-benchmarks.sh quick

# 标准测试 (~2分钟)
./run-benchmarks.sh standard

# 完整测试 (~5分钟)
./run-benchmarks.sh full

# 生成火焰图
./run-benchmarks.sh flamegraph

# 创建性能基线
./run-benchmarks.sh baseline

# 对比基线
./run-benchmarks.sh compare main
```

---

## 📝 测试覆盖率

### 已覆盖的性能维度

- ✅ 递归调用性能
- ✅ 尾调用优化
- ✅ 列表操作 (cons, car, cdr)
- ✅ Lambda 闭包
- ✅ 高阶函数 (map, reduce)
- ✅ 宏展开
- ✅ 文件解析
- ✅ 算术运算

### 待补充测试

- ⏳ FFI 调用性能
- ⏳ 惰性求值详细测试
- ⏳ 内存使用分析
- ⏳ 垃圾回收压力测试

---

## 🔧 优化建议

### 立即可行的优化 (无需 JIT)

1. **值表示优化**
   - 使用 NaN-boxing 减少 Rc 分配
   - 预期提升: 1.5-2x

2. **内联缓存**
   - 缓存变量查找结果
   - 预期提升: 1.2-1.5x

3. **栈分配优化**
   - 小列表内联到栈上
   - 预期提升: 1.3-1.5x

### JIT 相关优化

1. **热点检测**
   - 记录函数调用次数
   - 阈值建议: 100-1000 次

2. **类型特化**
   - 检测类型稳定路径
   - 生成类型特化代码

3. **内联优化**
   - 小函数自动内联
   - 减少调用开销

---

## 📚 参考资料

- [Criterion.rs 文档](https://bheisler.github.io/criterion.rs/book/)
- [Cranelift JIT 文档](https://docs.rs/cranelift/)
- [LuaJIT 架构](http://luajit.org/architecture.html)
- [RPython JIT](https://rpython.readthedocs.io/)

---

**最后更新**: 2025-01-30
**维护者**: MyLisp Team
