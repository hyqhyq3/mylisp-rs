# MyLisp 开发待办事项

**最后更新**: 2026-01-30 (局部变量和高级特性完成 ✅)

本文档按优先级列出了 MyLisp 项目的开发任务。基于性能基线测试结果，JIT 编译是最有价值的优化方向。

---

## 🔴 P0 - 核心功能（必须完成）

### [JIT-001] 完成字节码系统基础架构 ✅ **已完成**
**完成时间**: 2026-01-30 | **收益**: 为 JIT 奠定基础

**子任务**:
- [x] 添加 Criterion 基准测试依赖
- [x] 创建性能基线测试套件
- [x] 获取初始性能数据
- [x] 完成 `src/jit/bytecode.rs` - 操作码定义 ✅
- [x] 完成 `src/jit/compiler.rs` - AST → 字节码编译器 ✅
- [x] 完成 `src/jit/vm.rs` - 字节码虚拟机（基础）✅
- [x] 字节码反汇编器 ✅
- [x] 单元测试（15/15 通过，覆盖率 > 80%）✅

**验收标准**:
- [x] 可以编译简单表达式为字节码 ✅
- [x] 字节码 VM 可以执行基本运算 ✅
- [x] Lambda 表达式编译 ✅
- [ ] 性能提升（需等 VM 函数调用完成后测试）

**阶段报告**: [JIT_PHASE1_REPORT.md](./JIT_PHASE1_REPORT.md)

---

## 🟡 P1 - 高优先级（重大收益）

### [JIT-002] 字节码编译器增强 ✅ **Lambda 编译已完成**
**预计时间**: 3-5 天 | **预期收益**: **2-3x** 性能提升

**目标**: 将 AST 编译为优化的字节码

**关键功能**:
- [x] 常量表管理 ✅
- [x] 局部变量作用域分析 ✅
- [x] 跳转标签解析 ✅
- [ ] 尾调用优化在字节码级别实现
- [x] Lambda 表达式编译 ✅
- [x] 闭包捕获变量编译 ✅
- [x] 内置函数识别（26 个内置函数）✅

**新增功能** (2026-01-30):
- ✅ 支持 `(lambda (params...) body...)` 多参数形式
- ✅ 支持 `(lambda param body)` 单参数简写形式
- ✅ 闭包变量分析和捕获
- ✅ 嵌套 Lambda 编译
- ✅ 4 个 Lambda 专用测试

**阶段报告**: [JIT_PHASE2_LAMBDA_REPORT.md](./JIT_PHASE2_LAMBDA_REPORT.md)

**基于性能基线的优化重点**:
1. **算术运算优化** (当前 3.14 µs)
   - 直接生成算术指令
   - 减少函数调用开销

2. **列表操作优化** (当前 4.12 µs)
   - 优化 cons/head/tail 指令
   - 栈上小列表优化

3. **函数调用优化** (当前 2.13 µs)
   - 减少调用帧开销
   - 内置函数快速路径

**验收标准**:
- [x] Lambda 编译测试通过 ✅
- [ ] 所有测试用例通过（需 VM 函数调用）
- [ ] `fib(15)` 性能提升至 2-3 µs (1.3-2x)
- [ ] `map(square, 100)` 性能提升至 3 µs (1.3x)

---

### [JIT-003] 完善字节码虚拟机 ✅ **已完成**
**完成时间**: 2026-01-30 | **预期收益**: **2-3x** 性能提升

**目标**: 高效的字节码解释执行引擎

**关键功能**:
- [x] 栈管理（值栈、调用栈）✅
- [x] 调用帧管理（CallFrame 实现）✅
- [x] 操作分发循环（基础操作码）✅
- [ ] 异常处理
- [ ] 垃圾回收集成
- [x] **函数调用机制** ✅

**已完成工作**:
1. [x] 实现 `MakeLambda` 指令执行 ✅
2. [x] 实现 `Call` 指令执行（字节码 Lambda 调用）✅
3. [x] 实现调用帧管理（参数绑定、返回地址）✅
4. [x] 实现 `Return` 指令（恢复调用帧）✅
5. [x] 实现 `LoadBuiltin` 指令执行（字符串常量）✅
6. [x] Lambda 函数调用测试（3个测试全部通过）✅
7. [x] 闭包变量分析（编译时）✅
8. [x] 闭包变量运行时装载 ✅

**编译器修复**:
- [x] 函数调用编译顺序（参数先，函数后）✅
- [x] Lambda 函数体末尾自动添加 Return ✅
- [x] 局部变量 depth 计算修复 ✅
- [x] 内置函数使用字符串常量加载 ✅

**阶段报告**: [JIT_PHASE3_VM_CALL_REPORT.md](./JIT_PHASE3_VM_CALL_REPORT.md)

**验收标准**:
- [x] 所有测试用例通过（24/24 JIT 测试）✅
- [ ] 性能达到目标（2-3x 提升）（需性能测试验证）
- [ ] 内存使用 < 解释器模式的 2x（待验证）

---

### [JIT-004] 局部变量和高级特性 ✅ **已完成**
**完成时间**: 2026-01-30 | **预期收益**: 支持 let/set!/闭包

**目标**: 实现完整的局部变量管理和闭包支持

**关键功能**:
- [x] let 表达式编译 ✅
- [x] set! 表达式编译 ✅
- [x] 全局变量管理改进 ✅
- [x] 闭包变量运行时装载 ✅
- [x] LoadGlobal/StoreGlobal 指令实现 ✅

**新增功能** (2026-01-30):
- ✅ 支持 `(let ((var val)...) body...)` 语法
- ✅ 支持 `(set! var value)` 修改局部和全局变量
- ✅ 全局变量名称映射（索引 -> 名称）
- ✅ 闭包变量从环境动态获取
- ✅ 4 个新测试用例（let/set! 测试）

**阶段报告**: [JIT_PHASE4_LOCAL_VARS_REPORT.md](./JIT_PHASE4_LOCAL_VARS_REPORT.md)

**验收标准**:
- [x] let 表达式编译测试通过 ✅
- [x] set! 表达式编译测试通过 ✅
- [x] 28/28 JIT 测试全部通过 ✅
- [x] 性能基准测试完成 ✅

---

### [OPT-001] 值表示优化（NaN-boxing）💡 **无需 JIT 即可实现**
**预计时间**: 1-2 天 | **预期收益**: **1.5-2x** 性能提升

**问题**: 当前使用 `Rc<RefCell<Expr>>` 大量堆分配

**解决方案**: 使用 NaN-boxing 压缩值表示
```rust
// 当前: Rc<RefCell<Expr>> (~24 bytes + 堆分配)
// 优化后: u64 (8 bytes, 栈上)
```

**实施步骤**:
1. [ ] 定义 NaN-boxed 值类型
2. [ ] 实现 encoding/decoding
3. [ ] 更新所有表达式求值逻辑
4. [ ] 性能测试验证

**预期效果**:
- 减少堆分配 70-80%
- 缓存友好性提升
- **整体性能提升 1.5-2x**

**优先级理由**: 无需等待 JIT，立即见效，低风险

---

## 🟢 P2 - 中优先级（显著收益）

### [JIT-005] 集成 Cranelift JIT 编译器
**预计时间**: 5-7 天 | **预期收益**: **3-5x** 性能提升（热点函数）

**目标**: 将热点字节码编译为原生机器码

**关键功能**:
- [ ] 添加 Cranelift 依赖
- [ ] 实现字节码 → Cranelift IR 翻译
- [ ] JIT 函数调用约定
- [ ] 原生代码缓存
- [ ] 回退到解释器模式

**基于性能基线的优化重点**:
1. **算术运算**: 目标 **10-20x** 提升（3.14 µs → 0.3 µs）
2. **简单循环**: 目标 **5-10x** 提升
3. **尾递归**: 目标 **3-5x** 提升（3.90 µs → 1.0 µs）

**验收标准**:
- [ ] 热点函数性能提升 3-5x
- [ ] 编译延迟 < 100ms
- [ ] 不破坏现有功能

---

### [JIT-006] 热点检测与自适应编译
**预计时间**: 2-3 天 | **预期收益**: 自动优化热点路径

**目标**: 自动识别并编译高频执行的函数

**关键功能**:
- [ ] 函数调用计数器
- [ ] 热点阈值配置（建议：100-1000 次）
- [ ] 编译触发逻辑
- [ ] 编译结果缓存
- [ ] 去优化机制

**策略**:
- 阶段 1: 解释执行 + 计数
- 阶段 2: 达到阈值 → JIT 编译
- 阶段 3: 后续调用使用原生代码

**验收标准**:
- [ ] 热点函数自动编译
- [ ] 首次运行 < 原性能 10%
- [ ] 稳定后性能提升 3-5x

---

### [OPT-002] 内联缓存（Inline Caching）
**预计时间**: 2-3 天 | **预期收益**: **1.3-1.5x** 性能提升

**问题**: 变量查找每次都需要遍历环境链

**解决方案**: 缓存查找结果
```rust
struct InlineCache {
    slots: [CacheSlot; 4],
}

struct CacheSlot {
    depth: usize,
    offset: usize,
    hit_count: usize,
}
```

**实施步骤**:
1. [ ] 设计缓存槽结构
2. [ ] 在关键路径插入缓存
3. [ ] 缓存失效策略
4. [ ] 性能测试

**优化重点**:
- [ ] 变量查找
- [ ] 函数调用
- [ ] 列表操作

---

### [OPT-003] 栈上小列表优化
**预计时间**: 2-3 天 | **预期收益**: **1.3-1.5x** 性能提升

**问题**: 每次都堆分配列表

**解决方案**: 小列表内联到栈上
```rust
enum List {
    Inline([Value; 4], u8),      // 最多 4 个元素
    Heap(Box<ConsCell>),
}
```

**验收标准**:
- [ ] 小列表（< 4 元素）无堆分配
- [ ] `cons` 性能提升 30-50%
- [ ] 内存使用减少

---

## 🔵 P3 - 低优先级（锦上添花）

### [JIT-007] 类型特化
**预计时间**: 3-4 天 | **预期收益**: 额外 1.2-1.5x

**目标**: 检测类型稳定路径并生成特化代码

**关键功能**:
- [ ] 类型反馈收集
- [ ] 类型稳定路径检测
- [ ] 类型特化代码生成
- [ ] 去优化逻辑

---

### [JIT-008] 高级优化
**预计时间**: 5-7 天 | **预期收益**: 额外 1.5-2x

**优化技术**:
- [ ] 小函数内联
- [ ] 常量折叠
- [ ] 死代码消除
- [ ] 循环展开

---

### [TEST-001] 补充测试用例
**预计时间**: 2-3 天 | **收益**: 提高稳定性

**待补充测试**:
- [ ] FFI 调用性能测试
- [ ] 惰性求值详细测试
- [ ] 内存泄漏测试
- [ ] 并发安全性测试

---

### [DOC-001] 更新文档
**预计时间**: 1-2 天 | **收益**: 改善可用性**

**待更新文档**:
- [ ] JIT 编译器架构文档
- [ ] 性能调优指南
- [ ] 字节码指令参考
- [ ] 内联配置文档

---

## 📊 优先级决策矩阵

| 任务 | 实施时间 | 性能提升 | 风险 | ROI | 优先级 |
|------|---------|---------|------|-----|--------|
| **OPT-001: NaN-boxing** | 1-2天 | 1.5-2x | 低 | **极高** | 🔴 P1 |
| **JIT-002: 编译器** | 3-5天 | 2-3x | 中 | **高** | 🟡 P1 |
| **JIT-003: 字节码VM** | 4-6天 | 2-3x | 中 | **高** | 🟡 P1 |
| **JIT-004: Cranelift JIT** | 5-7天 | 3-5x | 高 | **高** | 🟢 P2 |
| **OPT-002: 内联缓存** | 2-3天 | 1.3-1.5x | 低 | 中 | 🟢 P2 |
| **OPT-003: 栈优化** | 2-3天 | 1.3-1.5x | 低 | 中 | 🟢 P2 |
| **JIT-005: 热点检测** | 2-3天 | 自动化 | 低 | 中 | 🟢 P2 |
| JIT-006: 类型特化 | 3-4天 | 1.2-1.5x | 高 | 低 | 🔵 P3 |
| JIT-007: 高级优化 | 5-7天 | 1.5-2x | 高 | 低 | 🔵 P3 |

---

## 🛣️ 推荐实施路线

### 路线 A: 快速见效（推荐）⚡
**总时间**: 1-2 周 | **预期提升**: **3-5x**

1. **OPT-001** (NaN-boxing) - 1-2天 → 1.5-2x
2. **JIT-002** (编译器) - 3-5天 → 额外 1.3x
3. **JIT-003** (字节码VM) - 4-6天 → 额外 1.3x
4. **OPT-002** (内联缓存) - 2-3天 → 额外 1.2x

**里程碑**:
- 第1周: 完成字节码系统 + NaN-boxing (2-3x 提升)
- 第2周: 完成优化和缓存 (3-5x 提升)

---

### 路线 B: 标准JIT路线 🚀
**总时间**: 3-4 周 | **预期提升**: **5-10x**

1. 完整字节码系统（JIT-001/002/003）
2. Cranelift JIT集成（JIT-004）
3. 热点检测（JIT-005）
4. 高级优化（JIT-006/007）

---

### 路线 C: 渐进式优化 🐢
**总时间**: 分散在多个迭代 | **预期提升**: 持续改进

1. 先实施 P0 任务
2. 每个 P1 任务独立验证
3. 根据性能基线决定下一步
4. 持续监控性能提升

---

## 🎯 近期目标（本周）

### ✅ 已完成 (2026-01-30)
- [x] 完成字节码系统基础（JIT-001）
- [x] 实现 lambda 编译器
- [x] 实现闭包变量分析
- [x] 15 个 JIT 测试全部通过
- [x] 24/24 JIT 测试全部通过（阶段 1c）

### 🔄 下一步
- [ ] 实现 `let` 表达式编译
- [ ] 实现 `set!` 表达式编译
- [ ] 闭包变量运行时装载和绑定
- [ ] 性能测试和基准测试

**预期结果**: 完整的字节码执行引擎，支持所有核心语言特性

---

## 📈 性能提升预测

| 阶段 | 累计时间 | 性能提升 | 主要优化 | 状态 |
|------|---------|---------|---------|------|
| **基线** | 0 | 1x | 纯解释器 | ✅ |
| **阶段 1a** | 1天 | - | 字节码系统基础架构 | ✅ 已完成 |
| **阶段 1b** | 1天 | - | Lambda 编译 | ✅ 已完成 |
| **阶段 1c** | 1天 | 1-1.5x | VM 函数调用 | ✅ 已完成 |
| **阶段 1d** | 1天 | - | 局部变量和高级特性 | ✅ 已完成 |
| **阶段 2** | 1周 | 2-3x | 字节码VM + 内联缓存 | ⏳ 待开始 |
| **阶段 3** | 2-3周 | 3-5x | Cranelift JIT + 热点检测 | ⏳ 待开始 |
| **阶段 4** | 4周+ | 5-10x | 类型特化 + 高级优化 | ⏳ 待开始 |

**当前进度**: 阶段 1d 完成，局部变量和高级特性已实现

---

## 💡 快速获胜（Quick Wins）

以下任务可以在 **1 天内**完成，并立即带来性能提升：

1. **移除警告** (30分钟) - 清理编译器警告
2. **内联简单函数** (2小时) - 手动内联热点函数
3. **减少 Rc 克隆** (3小时) - 使用引用代替克隆
4. **预分配 Vec 容量** (2小时) - 避免重复分配
5. **懒惰求值优化** (4小时) - 减少 thunk 创建

---

## 🔗 相关资源

- [性能基线报告](./BENCHMARKS.md) - 当前性能数据
- [基准测试指南](./benches/README.md) - 如何运行测试
- [JIT 实现计划](./AGENTS.md) - 详细的架构设计

---

**最后更新**: 2026-01-30 (局部变量和高级特性完成)
**下次审查**: 集成 JIT 到主解释器（预计 3-5 天）

## 📝 变更历史

- **2026-01-30**: 完成局部变量和高级特性（阶段 1d）
  - ✅ 实现 `let` 表达式编译
  - ✅ 实现 `set!` 表达式编译
  - ✅ 实现全局变量名称映射
  - ✅ 实现 LoadGlobal/StoreGlobal 指令
  - ✅ 实现闭包变量运行时装载
  - ✅ 添加 4 个新测试用例
  - ✅ 28/28 JIT 测试全部通过
  - ✅ 性能基准测试完成（解释器模式）
  - 📄 生成 JIT_PHASE4_LOCAL_VARS_REPORT.md

- **2026-01-30**: 完成 VM 函数调用机制（阶段 1c）
  - ✅ 实现 `MakeLambda` 指令
  - ✅ 实现 `Call` 指令（字节码 Lambda 调用）
  - ✅ 实现 `Return` 指令（调用帧恢复）
  - ✅ 实现 `LoadBuiltin` 指令
  - ✅ 修复编译器多个问题（调用顺序、局部变量 depth）
  - ✅ 添加 3 个 VM Lambda 测试
  - ✅ 24/24 JIT 测试全部通过
  - 📄 生成 JIT_PHASE3_VM_CALL_REPORT.md

- **2026-01-30**: 完成 Lambda 编译功能
  - ✅ 实现多参数和单参数形式 lambda
  - ✅ 实现闭包变量分析
  - ✅ 添加 4 个 lambda 测试
  - ✅ 15/15 JIT 测试通过
  - 📄 生成 JIT_PHASE2_LAMBDA_REPORT.md
